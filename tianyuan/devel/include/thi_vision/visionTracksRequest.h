// Generated by gencpp from file thi_vision/visionTracksRequest.msg
// DO NOT EDIT!


#ifndef THI_VISION_MESSAGE_VISIONTRACKSREQUEST_H
#define THI_VISION_MESSAGE_VISIONTRACKSREQUEST_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <thi_vision/orientation.h>
#include <thi_vision/orientation.h>
#include <thi_vision/pcArea.h>

namespace thi_vision
{
template <class ContainerAllocator>
struct visionTracksRequest_
{
  typedef visionTracksRequest_<ContainerAllocator> Type;

  visionTracksRequest_()
    : pointCloudFile()
    , fileType()
    , workpiece(0)
    , press(0.0)
    , width(0.0)
    , grooveWidth(0.0)
    , avoidLeft(0.0)
    , avoidRight(0.0)
    , length(0.0)
    , angleLeft()
    , angleRight()
    , listPcAreas()  {
    }
  visionTracksRequest_(const ContainerAllocator& _alloc)
    : pointCloudFile(_alloc)
    , fileType(_alloc)
    , workpiece(0)
    , press(0.0)
    , width(0.0)
    , grooveWidth(0.0)
    , avoidLeft(0.0)
    , avoidRight(0.0)
    , length(0.0)
    , angleLeft(_alloc)
    , angleRight(_alloc)
    , listPcAreas(_alloc)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _pointCloudFile_type;
  _pointCloudFile_type pointCloudFile;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _fileType_type;
  _fileType_type fileType;

   typedef int32_t _workpiece_type;
  _workpiece_type workpiece;

   typedef float _press_type;
  _press_type press;

   typedef float _width_type;
  _width_type width;

   typedef float _grooveWidth_type;
  _grooveWidth_type grooveWidth;

   typedef float _avoidLeft_type;
  _avoidLeft_type avoidLeft;

   typedef float _avoidRight_type;
  _avoidRight_type avoidRight;

   typedef float _length_type;
  _length_type length;

   typedef  ::thi_vision::orientation_<ContainerAllocator>  _angleLeft_type;
  _angleLeft_type angleLeft;

   typedef  ::thi_vision::orientation_<ContainerAllocator>  _angleRight_type;
  _angleRight_type angleRight;

   typedef std::vector< ::thi_vision::pcArea_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::thi_vision::pcArea_<ContainerAllocator> >> _listPcAreas_type;
  _listPcAreas_type listPcAreas;





  typedef boost::shared_ptr< ::thi_vision::visionTracksRequest_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::thi_vision::visionTracksRequest_<ContainerAllocator> const> ConstPtr;

}; // struct visionTracksRequest_

typedef ::thi_vision::visionTracksRequest_<std::allocator<void> > visionTracksRequest;

typedef boost::shared_ptr< ::thi_vision::visionTracksRequest > visionTracksRequestPtr;
typedef boost::shared_ptr< ::thi_vision::visionTracksRequest const> visionTracksRequestConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::thi_vision::visionTracksRequest_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::thi_vision::visionTracksRequest_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::thi_vision::visionTracksRequest_<ContainerAllocator1> & lhs, const ::thi_vision::visionTracksRequest_<ContainerAllocator2> & rhs)
{
  return lhs.pointCloudFile == rhs.pointCloudFile &&
    lhs.fileType == rhs.fileType &&
    lhs.workpiece == rhs.workpiece &&
    lhs.press == rhs.press &&
    lhs.width == rhs.width &&
    lhs.grooveWidth == rhs.grooveWidth &&
    lhs.avoidLeft == rhs.avoidLeft &&
    lhs.avoidRight == rhs.avoidRight &&
    lhs.length == rhs.length &&
    lhs.angleLeft == rhs.angleLeft &&
    lhs.angleRight == rhs.angleRight &&
    lhs.listPcAreas == rhs.listPcAreas;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::thi_vision::visionTracksRequest_<ContainerAllocator1> & lhs, const ::thi_vision::visionTracksRequest_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace thi_vision

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::thi_vision::visionTracksRequest_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::thi_vision::visionTracksRequest_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::thi_vision::visionTracksRequest_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::thi_vision::visionTracksRequest_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::thi_vision::visionTracksRequest_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::thi_vision::visionTracksRequest_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::thi_vision::visionTracksRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "7310b90945a93b256f7864c27e961494";
  }

  static const char* value(const ::thi_vision::visionTracksRequest_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x7310b90945a93b25ULL;
  static const uint64_t static_value2 = 0x6f7864c27e961494ULL;
};

template<class ContainerAllocator>
struct DataType< ::thi_vision::visionTracksRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "thi_vision/visionTracksRequest";
  }

  static const char* value(const ::thi_vision::visionTracksRequest_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::thi_vision::visionTracksRequest_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string pointCloudFile\n"
"string fileType     # \"ply\" \"pcd\" \"txt\"\n"
"int32  workpiece    #工件号 0:上半间 1:下半件 右面\n"
"float32 press       #下压量\n"
"float32 width       #道宽 单位mm\n"
"float32 grooveWidth #预留的槽宽\n"
"float32 avoidLeft   #x轴正方向左侧避障弧长\n"
"float32 avoidRight  #x轴正方向右侧避障弧长\n"
"float32 length      #可打磨的最长区域\n"
"orientation angleLeft  #x轴正方向左侧避障固定姿态角度(a,b,c对应法兰盘rpy)\n"
"orientation angleRight #x轴正方向右侧避障固定姿态角度\n"
"pcArea[] listPcAreas\n"
"\n"
"================================================================================\n"
"MSG: thi_vision/orientation\n"
"float32 a\n"
"float32 b\n"
"float32 c\n"
"\n"
"================================================================================\n"
"MSG: thi_vision/pcArea\n"
"position[] listPcPoint\n"
"\n"
"================================================================================\n"
"MSG: thi_vision/position\n"
"float32 x\n"
"float32 y\n"
"float32 z\n"
;
  }

  static const char* value(const ::thi_vision::visionTracksRequest_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::thi_vision::visionTracksRequest_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.pointCloudFile);
      stream.next(m.fileType);
      stream.next(m.workpiece);
      stream.next(m.press);
      stream.next(m.width);
      stream.next(m.grooveWidth);
      stream.next(m.avoidLeft);
      stream.next(m.avoidRight);
      stream.next(m.length);
      stream.next(m.angleLeft);
      stream.next(m.angleRight);
      stream.next(m.listPcAreas);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct visionTracksRequest_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::thi_vision::visionTracksRequest_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::thi_vision::visionTracksRequest_<ContainerAllocator>& v)
  {
    s << indent << "pointCloudFile: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.pointCloudFile);
    s << indent << "fileType: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.fileType);
    s << indent << "workpiece: ";
    Printer<int32_t>::stream(s, indent + "  ", v.workpiece);
    s << indent << "press: ";
    Printer<float>::stream(s, indent + "  ", v.press);
    s << indent << "width: ";
    Printer<float>::stream(s, indent + "  ", v.width);
    s << indent << "grooveWidth: ";
    Printer<float>::stream(s, indent + "  ", v.grooveWidth);
    s << indent << "avoidLeft: ";
    Printer<float>::stream(s, indent + "  ", v.avoidLeft);
    s << indent << "avoidRight: ";
    Printer<float>::stream(s, indent + "  ", v.avoidRight);
    s << indent << "length: ";
    Printer<float>::stream(s, indent + "  ", v.length);
    s << indent << "angleLeft: ";
    s << std::endl;
    Printer< ::thi_vision::orientation_<ContainerAllocator> >::stream(s, indent + "  ", v.angleLeft);
    s << indent << "angleRight: ";
    s << std::endl;
    Printer< ::thi_vision::orientation_<ContainerAllocator> >::stream(s, indent + "  ", v.angleRight);
    s << indent << "listPcAreas[]" << std::endl;
    for (size_t i = 0; i < v.listPcAreas.size(); ++i)
    {
      s << indent << "  listPcAreas[" << i << "]: ";
      s << std::endl;
      s << indent;
      Printer< ::thi_vision::pcArea_<ContainerAllocator> >::stream(s, indent + "    ", v.listPcAreas[i]);
    }
  }
};

} // namespace message_operations
} // namespace ros

#endif // THI_VISION_MESSAGE_VISIONTRACKSREQUEST_H
